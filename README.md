# ADHD-Timebox

### 一. 项目简介

**ADHD Timebox Agent 是一个帮助 ADHD人群 有效的使用时间盒设计的AI辅助系统。它不仅仅是一个待办清单，更是一个基于“时间盒”** 方法论的全流程执行教练。

**ADHD Timebox Agent** 通过Plan、Focus、Rewards 多个agent 配合多个tools ，解决 ADHD 人群常见的“优先级难划分”、“启动困难”、“时间盲区”和“执行中断”问题，通过降低认知负荷，帮助用户进入并保持心流状态。


### 二.时间盒
##### 1. 核心定义
**时间盒**是一种将任务「锁」进**特定时间段**的**单任务管理方法**。
它不是普通的 To-do List，而是**把任务与具体时间点绑定**。
而且要求**在规定时间内必须产出成果**。就像把任务关进一个个「盒子」里， 规定好开始和结束时间，  最重要的是**在这个盒子里只做这一件事**。

马斯克用时间盒管理法 一年完成的工作量，几乎是别人的八倍。
##### 2.怎么执行时间盒？
执行分为 **计划阶段** 、**执行阶段**和验收阶段 。
######  第一步：装盒（计划阶段）
- **列清单**  
  在每天开始前，列出所有待办事项。
- **挑重点**  
  只挑出 **最重要的 3–5 项任务**，而不是试图做完所有事。
- **定时间**  
  把任务填入日程表，设定明确的起止时间。  
  常见规格：**15 分钟 / 30 分钟 / 60 分钟**。
---
###### 第二步：封盒（执行阶段）
- **准时开启**  
  即使不想做，也要准时开始，  
  哪怕只是一个微小的启动动作（例如：打开文档）。
- **单核工作**  
  移除手机等干扰，一次只专注一件事。  
  不质疑计划，不中途切换任务。
---
###### 第三步：开盒（验收阶段）
- **准时结束**  
  时间一到就停止，  
  不追求完美，只要达到「可接受标准」。

- **简单庆祝**  
  划掉清单或奖励自己（比如吃点零食），  
  给大脑一个正向反馈。

---
##### 3、时间盒的核心规则
为了保证时间盒真正有效，需要遵守以下规则：

1. **动词导向**  
   任务要用动词描述（如「撰写报告」而不是「报告」）。

2. **不求完美**  
   目标是在有限时间内「完成」，  
   而不是无限期拖延追求完美。

3. **信任盒子**  
   一旦设定时间盒，执行时不要再纠结  
   「现在做这个对不对」，直接执行。

4. **休息也要装盒**  
   休息不是偷懒，而是恢复精力。  
   在任务之间安排 **5–10 分钟的休息盒**。

5. **大拆小，小合并**  
   - 大任务 → 拆解成小步骤  比如“完成年度报告”这个任务就太大了，你需要把它分解成：收
	集Q1-Q4的业务数据、分析增长趋势、写市场分析部分、制作数据
	图表、撰写总结和建议，等等。
   - 碎事（回微信、整理文件）→ 合并到一个时间盒集中处理

---

##### 4.时间盒为什么时间盒真的有效？

- **对抗帕金森定律**  
  工作会自动膨胀占满所有时间。  
  时间限制倒逼你提高效率，剔除细枝末节。

- **符合帕累托原则（二八法则）**  
  强迫你把精力集中在最重要的 20% 任务上。

- **节省脑力**  
  提前规划，执行时不再消耗脑力做选择，  
  避免决策疲劳。

- **获得掌控感与自由**  
  你不再被事情推着走，  
  而是获得专注于真正重要事情的自由。

- **提升专注力**  
  明确的截止时间能激活大脑前额叶皮层，  
  增强自我控制力。

---
### 三 设计理念与核心决策  
  
**ADHD Timebox Agent**的所有核心设计决策，都是建立在 **时间盒（Timeboxing）管理法的科学原理**上。

对于 ADHD 大脑，单纯要求“罗列任务”往往是无效的。因为 ADHD 的核心挑战正是**难以确立任务的优先级**，面对需要组织与整理的庞杂事务更是一场认知的灾难。

**ADHD Timebox Agent**采用了 **Multi-Agent 协作架构**，由一个中心调度Agent 和三个功能性 Agent 组成。系统通过状态锁机制 管理上下文，确保复杂的多轮对话任务能够完整执行。
#### 1. Orchestrator Agent 

**角色：** 系统的大脑与路由中心。

- **意图识别与分发：** 实时监听用户自然语言输入，分析意图并将任务路由至最合适的 Agent（Plan, Focus 或 Reward）。
![[Screenshot 2026-01-06 at 22.26.08.png]]
- **Agent Lock (会话锁定机制)：** 当某个 Agent 进入复杂任务流， 如规划任务 时，Orchestrator 会锁定控制权，直到该 Agent 明确发出 `Task Completed` 信号，才会重新接管调度。这确保了任务上下文的连续性，防止逻辑跳跃。

#### 2. Plan Agent

**角色：** 外置的“前额叶皮层”，负责任务的整理、整形与时间管理。

- **清单转时间盒 (List to Timebox)：** 用户只需倾倒碎片化的想法，比如：“今天要写agent代码 学英语 买菜 回邮件 ”，无需提前整理、排序或决策。Plan Agent 会自动分析认知负荷，将其整理并塞入 **15/30/60 分钟** 的时间盒中，将“混乱”转化为可执行的秩序。

- **任务整形 (Task Shaping)：**
    
    - **自动动词化：** 将模糊的名词（如“周报”）转化为清晰的动作（如“撰写周报”）。
    - **拆解与合并：** 自动将大任务拆解为30分钟内的子任务，或将碎片杂事合并，确保难度适中。
    - ![[Screenshot 2026-01-06 at 23.02.59.png]]
	![[Screenshot 2026-01-06 at 23.03.11.png]]
    ![[Screenshot 2026-01-06 at 23.04.23.png]]
![[Screenshot 2026-01-06 at 23.04.37.png]]
- ![[Screenshot 2026-01-06 at 23.07.19.png]]
- 会自动把这些日程 同步到 google calendar 里
- **弹性日程 (Dynamic Rescheduling)：** 支持“推迟 30 分钟”等自然语言指令，自动顺延后续计划，防止因一次超时导致整体计划崩塌的挫败感。
![[Screenshot 2026-01-06 at 23.14.16.png]]
![[Screenshot 2026-01-06 at 23.14.39.png]]
![[Screenshot 2026-01-06 at 23.17.05.png]]
![[Screenshot 2026-01-06 at 23.13.33 1.png]]
#### 3. Focus Agent (执行与守护)

**角色：** 心流守护者，负责对抗拖延与维持注意力。

- **微步启动 (Micro-steps)：** 检测到用户犹豫或拖延时，不进行施压，而是给出极低门槛的建议（如“先打开文档就好”），绕过杏仁核的焦虑反应。
    ![[Screenshot 2026-01-06 at 23.27.24.png]]
- **念头停车场 ：** 当用户在执行中产生杂念 如“突然想查新买的一次性胶片机能不能过安检 ”，Agent 会代替用户在后台搜索并存储摘要，让用户无需切换窗口，保护心流的连续性。
![[Screenshot 2026-01-06 at 22.30.32.png]]
![[Screenshot 2026-01-06 at 22.30.03.png]]
- **走神检测 (Distraction Detection)：** 实时监测输入设备状态。如果用户超过 5 分钟无鼠标/键盘操作，系统会主动发出温和提醒，拉回注意力。
![[Screenshot 2026-01-06 at 22.29.24.png]]
- **状态追踪：** 负责标记当前正在进行的任务及上下文管理。
![[Screenshot 2026-01-06 at 23.25.30.png]]
#### 4. Reward Agent (反馈与激励)

**角色：** 多巴胺提供者。

- **即时正反馈：** 当任务被标记为“完成”时，触发即时奖励。
    ![[Screenshot 2026-01-06 at 23.28.38.png]]
- **可视化激励：** 生成趣味性的 ASCII Art（如 Cowsay 动物形象）与鼓励语，为枯燥的任务结尾提供成就感与情绪价值。![[Screenshot 2026-01-06 at 22.28.24.png]]
![[Screenshot 2026-01-06 at 22.27.55.png]]



### 四 技术挑战与收获
#### 1. 从 "God Prompt" 到 Multi-Agent 架构

- **挑战：** 早期尝试使用单一 Agent 处理所有逻辑包括 规划、监督、奖励，导致 Prompt 过于臃肿。不仅 Token 消耗巨大，且系统极其脆弱——修改一个指令往往会导致其他无关功能的退化，调试难度呈指数级上升。
- 
- **收获：** 采用 **Orchestrator-Worker** 的多智能体协作模式，通过拆分为 `Plan`、`Focus`、`Reward` 三个独立 Agent，实现了模块化开发。现在每个 Agent 仅维护最小必要上下文，既降低了认知负荷，也使得针对性优化 变得安全且高效。
---
#### 2. 从Agent 到 Tools

在系统的早期设计中，我曾陷入“万物皆 Agent”的误区，例如设计了一个独立的 `Parking Agent` 专门负责记录用户的杂念。但在实际运行中，我发现了严重的问题，并最终通过 **Tool Use** 完成了架构重构。

当用户在专注时说“我想查个资料”，Orchestrator 需要将对话从 `Focus Agent` 切换到 `Parking Agent`。这种设计导致了不必要的上下文切换。
     **路由抖动：** 纯 Prompt 的路由切换往往不稳定，Orchestrator 容易在频繁的切换中丢失原始任务的上下文。
     **体验割裂**  仅仅为了“记个笔记”就切换整个 Agent 人格，不仅消耗 Token，还破坏了用户的心流体验。
    
- **重构时** 我将“念头停车场”降级为 作为 `Focus Agent` 的一个 **Tool**。
用户无需离开当前的专注模式，Agent 只需调用工具即可完成“卸载杂念”，保持了对话的连续性和稳定性。
---
#### 3. 用有限状态机解决 上下文漂移的问题

在开发早期，Orchestrator agent采用的是朴素的无状态路由 模式。这导致了一个严重的上下文漂移问题：
就是当Plan Agent 发起追问 例如：“你想定在几点？”，回复 “九点” 时，Orchestrator 往往因为丢失了上一轮的上下文，无法理解“九点”的含义，甚至错误地将其路由给其他 Agent，导致对话流程断裂，Agent 表现得“呆滞”。

为了解决这个问题，我放弃了依赖 LLM 自身记忆的做法，转而采用了 **“外部状态管理 + 确定性路由”** 的方案。

- LLM 的意图识别是概率性的。当 `Plan Agent` 需要与用户进行多轮交互 比如确认任务细节时，Orchestrator 经常误以为任务已结束，从而过早接管对话，导致逻辑断裂。
- 因此引入了类似 **有限状态机**的锁定机制。
    
    - 当 Agent 调用 `acquire_lock()` 工具时，系统进入 **Sticky Session** 模式。
    
    - Orchestrator 会暂时旁路意图识别逻辑，将后续所有的 User Input **强制路由**给当前持有锁的 Agent，直到其显式调用 `release_lock()`。这确保了Workflow 的原子性和完整性。

---

#### 4.Agent 的“重启失忆”问题

Plan Agent 缺乏“状态持久化感知”。尽管代码已经将用户的计划保存为 `daily_tasks.json` 文件，但每当程序重启或开始新会话时，Agent 表现得像第一次启动一样，完全不知道已有计划的存在。

**根本原因 (Root Cause)：**

- **LLM 的无状态性 (Statelessness)：** LLM 本身不具备长时记忆，只依赖当前的 `Context Window`（上下文窗口）。
    
- **上下文断层：** 虽然数据在磁盘上（持久化层），但在 Agent 初始化时，没有将这些数据加载回内存（应用层）并注入到 Prompt 中。Agent 和磁盘文件之间隔了一堵墙。
    
为了解决这个问题，我引入了一个架构层的中间件——**State Manager**，将“记忆的维护”从 Agent 的推理逻辑中剥离出来，交给确定性的代码处理。

状态注水  不再依赖 Agent 主动去“查”文件，而是采用**主动注入**策略：

我将 LLM 视为**无状态 (Stateless)** 的推理引擎。在每一轮对话发起前，代码层会先从后端读取最新的 `System State`（如当前时间、任务列表、剩余时间），将其组装成 Prompt **动态注入** 到当次请求中。

这样无论对话进行了多久，Agent 在每一轮都能看到“最新鲜、最客观”的世界状态，彻底根除了因记忆衰减导致的逻辑漂移。



#### 5. 引入 Memory 让agent 拥有长期记忆

一开始 **ADHD Timebox Agent** 通过 daily_tasks.json 和 上下文注 实现了状态持久化。它精确地记得“现在是 14:00，你在做任务 B，进度 50%”。哪怕重启，它读取 JSON 也能立刻恢复状态。
也能知道现在的任务是什么。但它的局限在于：它只能记住“设计好”的字段，比如 : start_time、end_time、status、title。但如果用户说了一句：“我发现我下午 2 点特别容易困，以后这个时间别排重活”。旧系统会因找不到 user_energy_pattern 这种字段，只能把这句话当做闲聊处理，或者存进 thought_parking 仅仅是个备忘录 别的agent 不会读 ，而在下次 Plan agent 排期时，依然会在下午 2 点排重活。

加入 Memory 后，拥有了“非结构化认知” 像一个贴身管家。它不仅看表格，还会拿个小本本记下用户的“脾气”和“习惯”。

- 旧系统：Plan Agent把任务扔给 Focus 就不管了。

- 新系统：Plan Agent 可以在 Memory 里留个便条——focus_note: "这个用户最近压力大，执行阶段多鼓励，少催促"。Focus Agent 虽然没参与排期，但看到这个便条，对你的语气就会变温柔。它让系统能从过去的互动中学习，产生那些 JSON 字段里装不下的“默契”和“直觉”。 



